from pcst_fast import pcst_fast
from anytree import Node, RenderTree
import numpy as np
import gen
import offline

def distance(v1,v2):			# Calculates Distance between two Vertices
	return round(((v1[0]-v2[0])**2+(v1[1]-v2[1])**2)**0.5,2)

def edges(vlist,E,ecost):		# Makes a List of Edges
	vlength = len(vlist)
	for i in range(vlength):
		for j in range(i+1,vlength):
			E.append((i,j))
			ecost.append(distance(vlist[i],vlist[j]))

def greedyS(v,S):				# Calculates Closest Distance from some vertex in S
	dlist = []
	for s in S:
		dlist.append((v[0]-s[0])**2+(v[1]-s[1])**2)
	return round(min(dlist)**0.5,2)

def greedyScap(v,Scap,Rcap):	# Calculates Closest Distance from some vertex in Scap
	mn = 400000000
	mni = -1
	for s in Scap:
		d2 = (v[0]-Rcap[s-1][0])**2 + (v[1]-Rcap[s-1][1])**2
		if d2<mn:
			mn,mni = d2,s
	return (round(mn**0.5,2),mni)

def getEdges(v,Ecap,ecost):		# Returns list of Edges that have v at one end
	edges = []
	for i in range(len(Ecap)):
		if Ecap[i][0]==v:
			edges.append((Ecap[i][1],ecost[i]))
		elif Ecap[i][1]==v:
			edges.append((Ecap[i][0],ecost[i]))
	return edges

def minNode(NodeList):			# Returns the index of Node with Minimum Value
	mn,mni = 400000000,-1
	for i in range(len(NodeList)):
		n = NodeList[i]
		if n.name[1]<mn:
			mn = n.name[1]
			mni = i
	return mni

def getSVcapRoute(v,Ecap,ecost,threshold):		# Returns route and its cost from v to S
	root = Node((v,0))
	VActive = [root]
	while True:
		i = minNode(VActive)
		if i==-1:
			return ([],-1)
		c = VActive[i].name[0]
		iEdges = getEdges(c,Ecap,ecost)
		for e in iEdges:
			if e[0]==0:
				if e[1]>=threshold:
					return ([],-1)
				else:
					xNode = VActive[i]
					cost = xNode.name[1]
					vList = [xNode.name[0]]
					while xNode.name[0]!=v:
						xNode = xNode.parent
						vList.append(xNode.name[0])
					return (vList,cost)
			else:
				b = (VActive[i]==root)
				if b:
					if e[1]<threshold:
						VActive.append(Node((e[0],VActive[i].name[1]+e[1]),parent=VActive[i]))
				else:

					if (e[1]<threshold) & (e[0]!=VActive[i].parent.name[0]):
						VActive.append(Node((e[0],VActive[i].name[1]+e[1]),parent=VActive[i]))
		VActive.pop(i)

def updateGraph1(v,Rcap,S,Scap,E,Ecap,ecost):	#Updates Database after a predicted vertex is included in the Graph
	S.append(Rcap[v-1])
	ind = np.where(Scap==v)
	Scap = np.delete(Scap,ind)

	for i in range(len(Ecap)):
		if Ecap[i][0]==v:
			Ecap[i]=(0,Ecap[i][1])
		elif Ecap[i][1]==v:
			Ecap[i]=(Ecap[i][0],0)

	for i in range(1,len(Rcap)):
		if i<v:
			if (0,i) in E:
				i1 = E.index((0,i))
				i2 = E.index((i,v))
				if ecost[i1]>ecost[i2]:
					ecost[i1]=ecost[i2]
				E.pop(i2)
				ecost.pop(i2)
		elif i==v:
			if (0,i) in E:
				i1 = E.index((0,i))
				E.pop(i1)
				ecost.pop(i1)
		else:
			if (0,i) in E:
				i1 = E.index((0,i))
				i2 = E.index((v,i))
				if ecost[i1]>ecost[i2]:
					ecost[i1]=ecost[i2]
				E.pop(i2)
				ecost.pop(i2)

def updateGraph2(v,Rcap,S,E,ecost):				#Updates Database after a new Terminal is included in the Graph
	S.append(v)
	for i in range(1,len(Rcap)):
		if (0,i) in E:
			j = E.index((0,i))
			d = distance(v,Rcap[i-1])
			if d<ecost[j]:
				ecost[j]=d

def on(R,Rcap,alg):					#Online Algorithm
	S = []						#(S(x,y) : All the fixed vertices in Graph)
	Scap = []					#(Scap(i) : Vertices generated by the PC Algorithm)
	E = []						#(E(i,j) : All the Edges)
	ecost = []					#(ecost(c) : Costs of Edges in list E)
	Ecap = []					#(Ecap(i,j) : Edges generated by the PC Algorithm)

	cost = 0					#(cost : Cost of the Algorithm)
	budget = 0					#(Budget : Budget for the PC Algorithm)

	for i in range(len(R)):
		r = R[i]
		if len(S)==0:
			S.append(r)
			edges(S+Rcap,E,ecost)
		else:
			min1 = greedyS(r,S)
			(min2,min2i) = greedyScap(r,Scap,Rcap)
			if min2<min1:
				(route,rCost) = getSVcapRoute(min2i,Ecap,ecost,min1)
				if rCost!=-1:
					cost+=rCost+min2
					for vx in route:
						updateGraph1(vx,Rcap,S,Scap,E,Ecap,ecost)
					if r!=Rcap[min2i-1]:
						updateGraph2(r,Rcap,S,E,ecost)
				else:
					cost+=min1
					updateGraph2(r,Rcap,S,E,ecost)
			else:
				cost+=min1
				updateGraph2(r,Rcap,S,E,ecost)

			if cost>=2*budget:
				budget=cost
				n = len(Rcap)
				f = 6

				if alg=='modified':
					if i>1:
						Rtemp = R[:i].copy()
						ctemp = offline.offline(Rtemp)
						f = round((ctemp/cost)**3,2)
						f = 6*f

				for u in range(n):
					(vs,es) = partial(n,E,ecost,u)
					pcost = 0
					ees = []
					for e in es:
						ees.append(E[e])
						pcost+=ecost[e]

					if pcost<=f*budget:
						Scap = vs
						Ecap = ees
						break
	return cost

def partial(n,E,ecost,u):		#Finds a suitable Prize Collecting Solution
	if 2*u>=n:
		return ([],[])
	else:
		vcost = []
		for i in range(n+1):
			vcost.append(1)
		vpre,epre = [],[]
		vv,ee = [],[]
		while n-len(vv)>=2*u:
			vpre,epre = vv,ee
			vv,ee = pcst_fast(E,vcost,ecost,0,1,'strong',0)
			for i in range(len(vcost)):
				vcost[i] = 2*vcost[i]
		u1 = n-len(vpre)
		u2 = n-len(vv)
		if 4*u>=u1+u2:
			return (vpre,epre)
		else:
			return (vv,ee)



#ters = gen.rter()
#rr = ters[0]
#prter = ters[1]

#print(on(rr,prter,'standard'))